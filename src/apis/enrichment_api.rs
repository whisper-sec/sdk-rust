/*
 * Whisper Security API
 *
 * # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |-------------------|------------|-------------| | Indicators (`/v1/indicators/_*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/_*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/_*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/_*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/_*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/_*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/_*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whisper.security
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`bulk_enrichment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkEnrichmentError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_indicator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIndicatorError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_indicator_graph`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIndicatorGraphError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_indicator_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIndicatorHistoryError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_predictive_risk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPredictiveRiskError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subdomains`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubdomainsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status404(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_indicators`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchIndicatorsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status429(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`similar_domains`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimilarDomainsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p>  <h4>Performance</h4> <p>Processing time depends on batch size and indicator types. IP enrichment is faster than domain enrichment.</p> <ul>     <li><b>IPs only:</b> 2-10 seconds for typical batches</li>     <li><b>Domains only:</b> 10-30 seconds (WHOIS lookups are slower)</li>     <li><b>Mixed:</b> 5-30 seconds depending on ratio</li> </ul>  <h4>Rate Limits</h4> <p>Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p>  <h4>Response Structure</h4> <p>When the job completes, the <code>result</code> field contains:</p> <ul>     <li><code>status</code>: \"completed\" or \"failed\"</li>     <li><code>results</code>: Array of enriched indicator objects (see below)</li>     <li><code>errors</code>: Array of failed enrichments with error details</li>     <li><code>totalProcessed</code>: Number of indicators processed</li>     <li><code>totalFailed</code>: Number of failed enrichments</li>     <li><code>totalIndicators</code>: Total indicators in request</li>     <li><code>successRate</code>: Percentage of successful enrichments (0-100)</li> </ul>  <h4>Result Item Structure</h4> <p>Each item in the <code>results</code> array includes:</p> <ul>     <li><code>indicator</code>: The original indicator value</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>query</code>: Request metadata (type, value, timestamp, response_time_ms)</li>     <li><code>summary</code>: Key information summary</li> </ul>  <p><b>For IP indicators:</b></p> <ul>     <li><code>geolocation</code>: Country, city, coordinates, ISP, ASN</li>     <li><code>network</code>: BGP routing data, prefix visibility, origins</li>     <li><code>isp</code>: ISP name, organization, ASN</li>     <li><code>reputation</code>: Risk score, blacklist scores</li>     <li><code>relationships</code>: Related domains, shared infrastructure</li> </ul>  <p><b>For domain indicators:</b></p> <ul>     <li><code>registration</code>: WHOIS data (registrar, dates, nameservers, status)</li>     <li><code>dns</code>: DNS records (A, AAAA, MX, NS, TXT, CNAME)</li>     <li><code>reputation</code>: Domain reputation, infrastructure scores</li>     <li><code>relationships</code>: Related domains, incoming/outgoing links</li> </ul>  <h4>Error Item Structure</h4> <p>Each item in the <code>errors</code> array includes:</p> <ul>     <li><code>indicator</code>: The indicator that failed</li>     <li><code>type</code>: \"ip\" or \"domain\"</li>     <li><code>error</code>: true</li>     <li><code>message</code>: Error description</li> </ul> 
pub async fn bulk_enrichment(configuration: &configuration::Configuration, bulk_request: models::BulkRequest) -> Result<models::BulkEnrichmentResult, Error<BulkEnrichmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_bulk_request = bulk_request;

    let uri_str = format!("{}/v1/ops/enrichment/bulk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_bulk_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkEnrichmentResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkEnrichmentResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkEnrichmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 
pub async fn get_indicator(configuration: &configuration::Configuration, r#type: &str, value: &str, include: Option<&str>) -> Result<models::IndicatorResponse, Error<GetIndicatorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_type = r#type;
    let p_path_value = value;
    let p_query_include = include;

    let uri_str = format!("{}/v1/indicators/{type}/{value}", configuration.base_path, type=crate::apis::urlencode(p_path_type), value=crate::apis::urlencode(p_path_value));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include {
        req_builder = req_builder.query(&[("include", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IndicatorResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IndicatorResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIndicatorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 
pub async fn get_indicator_graph(configuration: &configuration::Configuration, r#type: &str, value: &str, limit: Option<i32>) -> Result<models::GraphResponse, Error<GetIndicatorGraphError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_type = r#type;
    let p_path_value = value;
    let p_query_limit = limit;

    let uri_str = format!("{}/v1/indicators/{type}/{value}/graph", configuration.base_path, type=crate::apis::urlencode(p_path_type), value=crate::apis::urlencode(p_path_value));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GraphResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GraphResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIndicatorGraphError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 
pub async fn get_indicator_history(configuration: &configuration::Configuration, r#type: &str, value: &str, history_type: Option<&str>) -> Result<models::HistoryResponse, Error<GetIndicatorHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_type = r#type;
    let p_path_value = value;
    let p_query_history_type = history_type;

    let uri_str = format!("{}/v1/indicators/{type}/{value}/history", configuration.base_path, type=crate::apis::urlencode(p_path_type), value=crate::apis::urlencode(p_path_value));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_history_type {
        req_builder = req_builder.query(&[("historyType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HistoryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HistoryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIndicatorHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <p>Returns ML-based predictive risk assessment for an IP address or domain. Provides current risk scoring, 7-day and 30-day predictions, risk trajectory analysis, and contributing factors.</p> <h4>Response Includes:</h4> <ul>     <li><b>Current Assessment:</b> Risk score (0-100), risk level, and confidence</li>     <li><b>Predictions:</b> 7-day and 30-day risk forecasts with confidence intervals</li>     <li><b>Trajectory:</b> Trend direction (improving/stable/worsening), velocity, stability</li>     <li><b>Risk Factors:</b> Contributing factors with weights and descriptions</li>     <li><b>Early Warnings:</b> Signals indicating potential future risk changes</li>     <li><b>Similar Cases:</b> Historical indicators with similar profiles and their outcomes</li> </ul> <h4>Risk Levels:</h4> <ul>     <li><b>low:</b> Score 0-30 - Minimal observed risk</li>     <li><b>medium:</b> Score 31-60 - Moderate risk, warrants monitoring</li>     <li><b>high:</b> Score 61-80 - Elevated risk, investigation recommended</li>     <li><b>critical:</b> Score 81-100 - Severe risk, immediate action advised</li> </ul> <h4>Performance:</h4> <p>Pre-computed ML predictions. Response time typically under 500ms with 15-minute cache.</p> 
pub async fn get_predictive_risk(configuration: &configuration::Configuration, r#type: &str, value: &str) -> Result<models::PredictiveRiskResponse, Error<GetPredictiveRiskError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_type = r#type;
    let p_path_value = value;

    let uri_str = format!("{}/v1/indicators/{type}/{value}/predictive-risk", configuration.base_path, type=crate::apis::urlencode(p_path_type), value=crate::apis::urlencode(p_path_value));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PredictiveRiskResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PredictiveRiskResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPredictiveRiskError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.
pub async fn get_subdomains(configuration: &configuration::Configuration, domain: &str, limit: Option<i32>) -> Result<models::SubdomainResponse, Error<GetSubdomainsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain = domain;
    let p_query_limit = limit;

    let uri_str = format!("{}/v1/indicators/domain/{domain}/subdomains", configuration.base_path, domain=crate::apis::urlencode(p_path_domain));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubdomainResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubdomainResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubdomainsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///             <p>Initiates an asynchronous job to search domain registration (WHOIS) or IP geolocation records. This endpoint is extremely powerful for infrastructure discovery, threat hunting, and brand protection.</p>             <p><b>Performance Note:</b> WHOIS searches are data-intensive and can take over 50 seconds to complete. Geolocation searches are faster (5-10 seconds). This endpoint is asynchronous by design. Poll the <code>/v1/ops/jobs/{jobId}</code> endpoint to retrieve results.</p>              <h4>Search Types:</h4>             <p>The endpoint automatically routes to the appropriate backend based on the fields provided:</p>             <ul>                 <li><b>WHOIS Search:</b> Use registrant fields (registrantCompany, registrantEmail, etc.) or domain-related fields (tld, nameServer, etc.)</li>                 <li><b>Geolocation Search:</b> Use IP geolocation fields (city, country, asn, isp, etc.) to find IPs matching criteria</li>             </ul>              <h4>WHOIS Search Fields:</h4>             <table>                 <tr><th>Field</th><th>Type</th><th>Description</th></tr>                 <tr><td><code>tld</code></td><td>exact</td><td>Top-level domain (e.g., \"com\", \"org\", \"net\")</td></tr>                 <tr><td><code>registrarName</code></td><td>exact</td><td>Domain registrar name</td></tr>                 <tr><td><code>registrarIanaId</code></td><td>exact</td><td>IANA registrar ID</td></tr>                 <tr><td><code>registrantName</code></td><td>text</td><td>Domain registrant name (partial match)</td></tr>                 <tr><td><code>registrantCompany</code></td><td>text</td><td>Registrant organization/company (partial match)</td></tr>                 <tr><td><code>registrantEmail</code></td><td>text</td><td>Registrant email address (supports *@domain.com wildcards)</td></tr>                 <tr><td><code>registrantPhone</code></td><td>text</td><td>Registrant phone number</td></tr>                 <tr><td><code>registrantCountry</code></td><td>text</td><td>2-letter country code (e.g., \"US\", \"DE\")</td></tr>                 <tr><td><code>registrantCity</code></td><td>text</td><td>Registrant city</td></tr>                 <tr><td><code>nameServer</code></td><td>text</td><td>Name server hostname</td></tr>                 <tr><td><code>domainStatus</code></td><td>text</td><td>Domain status flag (e.g., \"clientTransferProhibited\")</td></tr>                 <tr><td><code>createdDate</code></td><td>exact</td><td>Domain creation date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>updatedDate</code></td><td>exact</td><td>Domain last update date (YYYY-MM-DD format)</td></tr>                 <tr><td><code>expiryDate</code></td><td>exact</td><td>Domain expiry date (YYYY-MM-DD format)</td></tr>             </table>              <h4>Geolocation Search Fields (query string syntax):</h4>             <table>                 <tr><th>Field</th><th>Description</th><th>Example</th></tr>                 <tr><td><code>city</code></td><td>City name</td><td><code>city:London</code></td></tr>                 <tr><td><code>country</code></td><td>Country name</td><td><code>country:Germany</code></td></tr>                 <tr><td><code>asn</code></td><td>Autonomous System Number</td><td><code>asn:15169</code> (Google)</td></tr>                 <tr><td><code>isp</code></td><td>Internet Service Provider name</td><td><code>isp:Cloudflare</code></td></tr>                 <tr><td><code>organization</code></td><td>Organization name</td><td><code>organization:Amazon</code></td></tr>                 <tr><td><code>region</code></td><td>Region/State</td><td><code>region:California</code></td></tr>                 <tr><td><code>postal_code</code></td><td>Postal/ZIP code</td><td><code>postal_code:94043</code></td></tr>                 <tr><td><code>continent</code></td><td>Continent</td><td><code>continent:Europe</code></td></tr>             </table>              <h4>Example Requests:</h4>             <p><b>WHOIS search (field-based):</b></p>             <pre>{   \"registrantCompany\": \"Google\",   \"registrantCountry\": \"US\",   \"limit\": 100,   \"page\": 0 }</pre>             <p><b>Geolocation search (find IPs by ASN):</b></p>             <pre>{   \"query\": \"asn:15169\",   \"limit\": 100 }</pre>             <p><b>Geolocation search (find IPs by city):</b></p>             <pre>{   \"query\": \"city:Mountain View\",   \"limit\": 100 }</pre>             <p><b>Date-based domain search:</b></p>             <pre>{   \"createdDate\": \"2024-01-15\",   \"tld\": \"com\",   \"limit\": 100 }</pre>              <h4>Pagination:</h4>             <ul>                 <li><code>limit</code>: Maximum 100 results per page (default: 100)</li>                 <li><code>page</code>: 0-indexed page number (default: 0)</li>                 <li><code>offset</code>: Alternative to page - number of results to skip</li>             </ul>              <h4>Use Cases:</h4>             <ul>                 <li><b>Threat hunting:</b> Find domains/IPs registered by known malicious actors</li>                 <li><b>Infrastructure mapping:</b> Find all IPs in a specific ASN or organization</li>                 <li><b>Brand protection:</b> Monitor for domains similar to your brand</li>                 <li><b>Geolocation analysis:</b> Find IPs in specific geographic regions</li>                 <li><b>Investigation:</b> Track domains created on specific dates or IPs from specific ISPs</li>             </ul>              <h4>Security:</h4>             <p>All search parameters are validated for:</p>             <ul>                 <li>SQL injection prevention</li>                 <li>Command injection prevention</li>                 <li>Input length limits</li>                 <li>Format validation (dates, emails, country codes, etc.)</li>             </ul> 
pub async fn search_indicators(configuration: &configuration::Configuration, search_request: models::SearchRequest) -> Result<models::SearchResponse, Error<SearchIndicatorsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_search_request = search_request;

    let uri_str = format!("{}/v1/ops/enrichment/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchIndicatorsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <p>Finds domains similar to the provided domain using various similarity detection techniques. This endpoint is useful for brand protection, typosquatting detection, and threat hunting.</p>  <h4>Supported Techniques:</h4> <p>Specify techniques in the <code>techniques</code> array. If not specified, defaults to <code>typosquatting</code>.</p> <ul>     <li><b>typosquatting</b> - Keyboard proximity errors and common typos (e.g., gooogle.com, gogle.com)</li>     <li><b>homoglyph</b> - Visually similar Unicode characters (e.g., gооgle.com using Cyrillic 'о')</li>     <li><b>tld_variation</b> - Different TLD variations (e.g., google.net, google.org)</li>     <li><b>sounding</b> - Phonetically similar domains</li>     <li><b>prefix</b> - Domains starting with the target</li>     <li><b>suffix</b> - Domains ending with the target</li>     <li><b>contains</b> - Domains containing the target as a substring</li>     <li><b>levenshtein</b> - Edit distance similarity</li> </ul>  <h4>Example Request:</h4> <pre><code>{   \"domain\": \"google.com\",   \"techniques\": [\"typosquatting\", \"homoglyph\", \"tld_variation\"],   \"limit\": 100 }</code></pre>  <h4>Response Format:</h4> <p>Poll <code>/v1/ops/jobs/{jobId}</code> to get results. The result contains:</p> <pre><code>{   \"domain\": \"google.com\",   \"status\": \"completed\",   \"similarDomains\": [     {\"domain\": \"gooogle.com\", \"technique\": \"TYPO\"},     {\"domain\": \"gооgle.com\", \"technique\": \"UTFVARS\"}   ],   \"totalCount\": 200,   \"analysis\": {     \"techniquesUsed\": \"TYPO,UTFVARS\",     \"baseDomain\": \"google.com\",     \"searchLimit\": 100   } }</code></pre>  <h4>Performance:</h4> <p>Typically completes in 5-15 seconds. Multiple techniques run in parallel.</p>  <h4>Note:</h4> <p>The <code>check_registration</code>, <code>include_dns</code>, and <code>include_risk_score</code> options are not currently supported by the backend service and will be ignored.</p> 
pub async fn similar_domains(configuration: &configuration::Configuration, similar_domains_ops_request: models::SimilarDomainsOpsRequest) -> Result<models::SimilarDomainsResponse, Error<SimilarDomainsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_similar_domains_ops_request = similar_domains_ops_request;

    let uri_str = format!("{}/v1/ops/enrichment/similar-domains", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_similar_domains_ops_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SimilarDomainsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SimilarDomainsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SimilarDomainsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

