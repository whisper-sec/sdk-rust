/*
 * Whisper Security API
 *
 * # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |-------------------|------------|-------------| | Indicators (`/v1/indicators/_*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/_*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/_*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/_*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/_*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/_*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/_*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whisper.security
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// SearchRequest : Search query for finding domains matching WHOIS registration criteria.  **Query Modes:** 1. **Field-based (recommended):** Specify individual fields like `registrantCompany`, `tld`, etc. 2. **Query string:** Use `query` field with `field:value` syntax for compatibility.  Multiple criteria are combined with AND logic. Results are paginated with a maximum of 100 results per page.  **Use Cases:** - Threat hunting: Find domains registered by known malicious actors - Brand protection: Monitor for domains similar to your brand - Infrastructure discovery: Map domains sharing registrants or nameservers - Investigation: Track domains created on specific dates 
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct SearchRequest {
    #[serde(rename = "effectivePage", skip_serializing_if = "Option::is_none")]
    pub effective_page: Option<i32>,
    /// Search query using field:value syntax (alternative to individual field parameters). If individual field parameters are provided, they take precedence.  **Supported Syntax:** - Single field: `registrantCompany:Google` - Multiple fields: `registrantCompany:Google registrantCountry:US`  **Note:** For new integrations, prefer using individual field parameters instead of query syntax. 
    #[serde(rename = "query", skip_serializing_if = "Option::is_none")]
    pub query: Option<String>,
    /// Field to search in when using simple query mode. Use with `query` parameter.
    #[serde(rename = "field", skip_serializing_if = "Option::is_none")]
    pub field: Option<Field>,
    /// Top-Level Domain to filter by (exact match). Examples: com, org, net, io
    #[serde(rename = "tld", skip_serializing_if = "Option::is_none")]
    pub tld: Option<String>,
    /// Domain registrar name to filter by (exact match)
    #[serde(rename = "registrarName", skip_serializing_if = "Option::is_none")]
    pub registrar_name: Option<String>,
    /// IANA registrar ID to filter by (exact match)
    #[serde(rename = "registrarIanaId", skip_serializing_if = "Option::is_none")]
    pub registrar_iana_id: Option<String>,
    /// Registrant name to search for (text search, partial match)
    #[serde(rename = "registrantName", skip_serializing_if = "Option::is_none")]
    pub registrant_name: Option<String>,
    /// Registrant company/organization to search for (text search, partial match)
    #[serde(rename = "registrantCompany", skip_serializing_if = "Option::is_none")]
    pub registrant_company: Option<String>,
    /// Registrant email to search for (text search). Supports wildcards like *@example.com
    #[serde(rename = "registrantEmail", skip_serializing_if = "Option::is_none")]
    pub registrant_email: Option<String>,
    /// Registrant phone number to search for (text search)
    #[serde(rename = "registrantPhone", skip_serializing_if = "Option::is_none")]
    pub registrant_phone: Option<String>,
    /// Registrant country code to filter by (2-letter ISO code)
    #[serde(rename = "registrantCountry", skip_serializing_if = "Option::is_none")]
    pub registrant_country: Option<String>,
    /// Registrant city to search for (text search)
    #[serde(rename = "registrantCity", skip_serializing_if = "Option::is_none")]
    pub registrant_city: Option<String>,
    /// Name server hostname to search for (text search)
    #[serde(rename = "nameServer", skip_serializing_if = "Option::is_none")]
    pub name_server: Option<String>,
    /// Domain status flag to search for (text search). E.g., clientTransferProhibited
    #[serde(rename = "domainStatus", skip_serializing_if = "Option::is_none")]
    pub domain_status: Option<String>,
    /// Domain creation date to filter by (exact match, format: YYYY-MM-DD)
    #[serde(rename = "createdDate", skip_serializing_if = "Option::is_none")]
    pub created_date: Option<String>,
    /// Domain last update date to filter by (exact match, format: YYYY-MM-DD)
    #[serde(rename = "updatedDate", skip_serializing_if = "Option::is_none")]
    pub updated_date: Option<String>,
    /// Domain expiry date to filter by (exact match, format: YYYY-MM-DD)
    #[serde(rename = "expiryDate", skip_serializing_if = "Option::is_none")]
    pub expiry_date: Option<String>,
    /// Maximum number of results to return per page (max 100 for WHOIS searches)
    #[serde(rename = "limit", skip_serializing_if = "Option::is_none")]
    pub limit: Option<i32>,
    /// Page number for pagination (0-indexed). Alternative to offset.
    #[serde(rename = "page", skip_serializing_if = "Option::is_none")]
    pub page: Option<i32>,
    /// Number of results to skip for pagination. Converted to page internally.
    #[serde(rename = "offset", skip_serializing_if = "Option::is_none")]
    pub offset: Option<i32>,
}

impl SearchRequest {
    /// Search query for finding domains matching WHOIS registration criteria.  **Query Modes:** 1. **Field-based (recommended):** Specify individual fields like `registrantCompany`, `tld`, etc. 2. **Query string:** Use `query` field with `field:value` syntax for compatibility.  Multiple criteria are combined with AND logic. Results are paginated with a maximum of 100 results per page.  **Use Cases:** - Threat hunting: Find domains registered by known malicious actors - Brand protection: Monitor for domains similar to your brand - Infrastructure discovery: Map domains sharing registrants or nameservers - Investigation: Track domains created on specific dates 
    pub fn new() -> SearchRequest {
        SearchRequest {
            effective_page: None,
            query: None,
            field: None,
            tld: None,
            registrar_name: None,
            registrar_iana_id: None,
            registrant_name: None,
            registrant_company: None,
            registrant_email: None,
            registrant_phone: None,
            registrant_country: None,
            registrant_city: None,
            name_server: None,
            domain_status: None,
            created_date: None,
            updated_date: None,
            expiry_date: None,
            limit: None,
            page: None,
            offset: None,
        }
    }
}
/// Field to search in when using simple query mode. Use with `query` parameter.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Field {
    #[serde(rename = "registrantName")]
    RegistrantName,
    #[serde(rename = "registrantCompany")]
    RegistrantCompany,
    #[serde(rename = "registrantEmail")]
    RegistrantEmail,
    #[serde(rename = "registrantPhone")]
    RegistrantPhone,
    #[serde(rename = "registrantCountry")]
    RegistrantCountry,
    #[serde(rename = "registrantCity")]
    RegistrantCity,
    #[serde(rename = "nameServer")]
    NameServer,
    #[serde(rename = "registrarName")]
    RegistrarName,
    #[serde(rename = "registrarIanaId")]
    RegistrarIanaId,
    #[serde(rename = "tld")]
    Tld,
    #[serde(rename = "domainStatus")]
    DomainStatus,
    #[serde(rename = "createdDate")]
    CreatedDate,
    #[serde(rename = "updatedDate")]
    UpdatedDate,
    #[serde(rename = "expiryDate")]
    ExpiryDate,
}

impl Default for Field {
    fn default() -> Field {
        Self::RegistrantName
    }
}

